"use client"

import { useState, useEffect, useRef, useCallback } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { Textarea } from "@/components/ui/textarea"
import { FileText, Phone, User, Trash2, Loader2, RefreshCw, Clock, Users } from "lucide-react"
import { AuthApiService } from "@/lib/services/auth-api"

// Constants
const API_BASE_URL = "http://20.77.41.130:3000/api/v1"

// GLOBAL SINGLETON TO PREVENT MULTIPLE FETCHES
let globalFetchInProgress = false
let globalFetchPromise: Promise<any> | null = null

// Types
interface OrderItem {
  order_item_id: string
  quantity: number
  unit_price: string | number
  notes?: string
  special_instructions?: string
  product?: {
    product_id: string
    name: string
    category: {
      category_id: string
      name: string
    }
  }
  productSize?: {
    product_size_id: string
    price: string
    size: {
      size_id: string
      size_name: string
    }
  }
  product_size?: {
    product_name: string
    size_name: string
    price: string | number
    size?: {
      size_name: string
    }
  }
  extras?: Array<{
    extra_id?: string
    name?: string
    price?: string | number
    quantity?: number
  }>
  product_name?: string
  size_name?: string
  price?: number
  total_price?: number
}

interface Order {
  order_id: string
  customer_name: string
  order_type: "dine-in" | "takeaway" | "delivery"
  phone_number?: string
  total_price: string | number
  status: "pending" | "active" | "completed" | "cancelled"
  payment_method: "cash" | "card"
  created_at: string
  updated_at?: string
  shift_id?: string
  cashier?: {
    user_id: string
    full_name: string
  }
  shift?: {
    shift_id: string
    shift_name?: string
  }
  items: OrderItem[]
  cashier_name?: string
}

interface Shift {
  shift_id: string
  shift_name?: string
  start_time: string
  end_time?: string
  status: "active" | "closed" | "pending_close"
  cashier_id: string
  created_at: string
}

interface OrderStats {
  totalOrders: number
  totalRevenue: number
  ordersByType: {
    "dine-in": number
    takeaway: number
    delivery: number
  }
  ordersByStatus: {
    completed: number
    cancelled: number
  }
}

interface CategorySales {
  categoryName: string
  products: {
    [productName: string]: {
      quantity: number
      totalAmount: number
      unitPrice: number
    }
  }
  categoryTotal: number
}

// Helper Functions
const normalizePrice = (price: string | number): number => {
  if (typeof price === "string") {
    return Number.parseFloat(price) || 0
  }
  return Number(price) || 0
}

const formatPrice = (price: string | number): string => {
  return `${normalizePrice(price).toFixed(2)} ÿ¨.ŸÖ`
}

const generateId = (): string => {
  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Enhanced normalizeOrderItem with better error handling
const normalizeOrderItem = (item: any): OrderItem => {
  let productName = "ŸÖŸÜÿ™ÿ¨ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ"
  let sizeName = "ÿπÿßÿØŸä"
  let unitPrice = "0"

  try {
    // Strategy 1: Check product_size (API response structure) - PRIORITY
    if (item.product_size) {
      productName = item.product_size.product_name || productName
      if (item.product_size.size && item.product_size.size.size_name) {
        sizeName = item.product_size.size.size_name
      } else if (item.product_size.size_name) {
        sizeName = item.product_size.size_name
      }
      unitPrice = String(item.product_size.price || item.unit_price || 0)
    }
    // Strategy 2: Check product object with productSize
    else if (item.product && item.product.name) {
      productName = item.product.name
      if (item.productSize?.size?.size_name) {
        sizeName = item.productSize.size.size_name
        unitPrice = String(item.productSize.price || item.unit_price || 0)
      } else {
        unitPrice = String(item.unit_price || 0)
      }
    }
    // Strategy 3: Direct fields (from localStorage or other sources)
    else if (item.product_name) {
      productName = item.product_name
      sizeName = item.size_name || sizeName
      unitPrice = String(item.unit_price || item.price || 0)
    }
    // Strategy 4: Try to extract from any available data
    else {
      const possibleNames = [item.name, item.product?.name, item.productName].filter(Boolean)
      if (possibleNames.length > 0) {
        productName = possibleNames[0]
      }
      unitPrice = String(item.unit_price || item.price || 0)
    }
  } catch (error) {
    console.error(`‚ùå Error normalizing order item:`, error, item)
    productName = item.product_name || item.name || "ŸÖŸÜÿ™ÿ¨ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ"
    sizeName = item.size_name || "ÿπÿßÿØŸä"
    unitPrice = String(item.unit_price || item.price || 0)
  }

  // Robust extras handling for both flat and nested structures
  let processedExtras = []
  if (Array.isArray(item.extras) && item.extras.length > 0) {
    processedExtras = item.extras.map((extra: any) => {
      // Support both flat and nested (extra.extra) structures
      const extraObj = extra.extra || extra
      let extraName = extraObj.name || extraObj.extra_name || extraObj.extraName
      if (!extraName && extraObj.extra_id) {
        extraName = `ÿ•ÿ∂ÿßŸÅÿ© ${extraObj.extra_id.slice(-4)}`
      }
      if (!extraName) {
        extraName = "[ÿ•ÿ∂ÿßŸÅÿ© ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅÿ©]"
      }
      return {
        extra_id: extraObj.extra_id || extraObj.id || `extra_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
        name: extraName,
        price: typeof extraObj.price === "string" ? Number.parseFloat(extraObj.price) : extraObj.price || 0,
        quantity: extraObj.quantity ?? 1,
      }
    })
  }

  return {
    ...item,
    order_item_id: item.order_item_id || `item_${generateId()}`,
    product_name: productName,
    size_name: sizeName,
    unit_price: unitPrice,
    quantity: item.quantity || 0,
    extras: processedExtras,
    extrasCount: processedExtras.length,
  }
}

const normalizeOrder = (order: any): Order => {
  // Enhanced cashier name extraction
  let cashierName = "ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ"
  // Try multiple sources for cashier name
  if (order.cashier?.full_name) {
    cashierName = order.cashier.full_name
  } else if (order.cashier?.fullName) {
    cashierName = order.cashier.fullName
  } else if (order.cashier?.name) {
    cashierName = order.cashier.name
  } else if (order.cashier_name) {
    cashierName = order.cashier_name
  } else if (order.created_by_name) {
    cashierName = order.created_by_name
  } else if (order.user?.full_name) {
    cashierName = order.user.full_name
  } else if (order.user?.name) {
    cashierName = order.user.name
  }

  return {
    ...order,
    order_id: order.order_id || `order_${generateId()}`,
    total_price: typeof order.total_price === "string" ? order.total_price : String(order.total_price || 0),
    cashier_name: cashierName,
    customer_name: order.customer_name || "ÿπŸÖŸäŸÑ ÿπÿßÿ®ÿ±",
    phone_number: order.phone_number || order.customer_phone || null,
    order_type: order.order_type || "dine-in",
    status: "completed",
    payment_method: order.payment_method || "cash",
    created_at: order.created_at || new Date().toISOString(),
    shift_id: order.shift_id,
    items: Array.isArray(order.items) ? order.items.map(normalizeOrderItem) : [],
  }
}

// Fetch current user's active shift
const fetchCurrentShift = async (cashierId: string): Promise<Shift | null> => {
  try {
    console.log(`üîç Fetching shifts for cashier ${cashierId}`)
    const result = await AuthApiService.apiRequest<any>(`/shifts/cashier/${cashierId}`)
    console.log(`üìä Shifts response:`, result)
    if (result.success && result.data) {
      const shifts = Array.isArray(result.data.shifts)
        ? result.data.shifts
        : Array.isArray(result.data)
          ? result.data
          : []

      // Find active shift first
      const activeShift = shifts.find((shift: Shift) => shift.status === "active")
      if (activeShift) {
        console.log(`‚úÖ Found active shift: ${activeShift.shift_id}`)
        return activeShift
      }

      // If no active shift, get the most recent one
      if (shifts.length > 0) {
        const mostRecentShift = shifts.sort(
          (a: Shift, b: Shift) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime(),
        )[0]
        console.log(`‚úÖ Using most recent shift: ${mostRecentShift.shift_id}`)
        return mostRecentShift
      }
    }
  } catch (error) {
    console.error(`‚ùå Error fetching shifts:`, error)
  }
  return null
}

// Enhanced fetchOrderItems with better error handling
const fetchOrderItems = async (orderId: string): Promise<OrderItem[]> => {
  try {
    console.log(`üîç Fetching items for order ${orderId}`)
    const result = await AuthApiService.apiRequest<any>(`/order-items/order/${orderId}`)
    console.log(`üì¶ Items response for order ${orderId}:`, result)
    if (result.success && result.data) {
      let items = []
        if (Array.isArray(result.data.order_items)) {
          items = result.data.order_items
        } else if (Array.isArray(result.data)) {
          items = result.data
        }
        console.log(`‚úÖ Found ${items.length} items for order ${orderId}`)
        return items.map(normalizeOrderItem)
      }
  } catch (error) {
    console.error(`‚ùå Error fetching items for order ${orderId}:`, error)
  }
  return []
}

// SHIFT-AWARE FETCH FUNCTION (now uses except-cafe endpoint)
const fetchFromAPI = async (shiftId: string): Promise<Order[]> => {
  if (globalFetchInProgress && globalFetchPromise) {
    console.log("üîÑ Reusing existing fetch promise...")
    return await globalFetchPromise
  }
  globalFetchInProgress = true
  globalFetchPromise = (async () => {
    try {
      console.log(`üåê Fetching all non-cafe orders from except-cafe endpoint`)
      // Use the new endpoint with AuthApiService
      const result = await AuthApiService.apiRequest<any>('/orders/except-cafe')
      let orders = []
      console.log(`üìä except-cafe orders response:`, result)
      if (result.success && result.data) {
        orders = Array.isArray(result.data.orders)
          ? result.data.orders
          : Array.isArray(result.data)
            ? result.data
            : []
        console.log(`‚úÖ Found ${orders.length} non-cafe orders`)
      }
      // Filter by shiftId on the frontend
      const filteredOrders = orders.filter((order: any) => order.shift?.shift_id === shiftId || order.shift_id === shiftId)
      // Fetch items for each order (if needed)
      const ordersWithItems = await Promise.all(
        filteredOrders.map(async (order: any) => {
          const orderId = order.order_id || order.id
          try {
            const orderItems = await fetchOrderItems(orderId)
            return {
              ...order,
              items: orderItems,
            }
          } catch (error) {
            return {
              ...order,
              items: [],
            }
          }
        })
      )
      const finalOrders = ordersWithItems.filter((order) => order && order.order_id).map(normalizeOrder)
      return finalOrders
    } catch (error) {
      console.error("‚ùå API fetch failed:", error)
      return []
    } finally {
      globalFetchInProgress = false
      globalFetchPromise = null
    }
  })()
  return await globalFetchPromise
}

const fetchFromLocalStorage = (shiftId?: string): Order[] => {
  try {
    const localOrders = JSON.parse(localStorage.getItem("savedOrders") || "[]")
    const normalizedOrders = localOrders.filter((order: any) => order && order.order_id).map(normalizeOrder)
    // Filter by shift if shiftId is provided
    if (shiftId) {
      return normalizedOrders.filter((order: Order) => order.shift_id === shiftId)
    }
    return normalizedOrders
  } catch (error) {
    console.error("Failed to fetch from localStorage:", error)
    return []
  }
}

const deleteOrderFromAPI = async (orderId: string, reason: string, cashier: string): Promise<boolean> => {
  try {
    console.log(`üóëÔ∏è Attempting to delete order ${orderId}`)
    const result = await AuthApiService.apiRequest<any>(`/orders/${orderId}`, {
      method: "DELETE",
      body: JSON.stringify({
        deletion_reason: reason,
        deleted_by: cashier,
      }),
    })
    console.log(`‚úÖ Order ${orderId} deleted successfully`)
    return true
  } catch (error) {
    console.error("‚ùå API delete failed:", error)
    return false
  }
}

const deleteOrderFromLocalStorage = (orderId: string): void => {
  try {
    const savedOrders = JSON.parse(localStorage.getItem("savedOrders") || "[]")
    const updatedOrders = savedOrders.filter((order: Order) => order.order_id !== orderId)
    localStorage.setItem("savedOrders", JSON.stringify(updatedOrders))
  } catch (error) {
    console.error("Failed to update localStorage:", error)
  }
}

// Enhanced category detection function for specific restaurant categories
const getCategoryName = (item: OrderItem): string => {
  // Method 1: Check product.category.name
  if (item.product?.category?.name) {
    return item.product.category.name
  }

  // Method 2: Check product_size.category.name
  if (
    item.product_size &&
    typeof item.product_size === "object" &&
    "category" in item.product_size &&
    (item.product_size as any).category &&
    typeof (item.product_size as any).category === "object" &&
    "name" in (item.product_size as any).category
  ) {
    return (item.product_size as any).category.name
  }

  // Method 3: Enhanced product name analysis with specific restaurant categories
  const productName = (item.product_name || item.product?.name || "").toLowerCase()

  if (productName) {
    // ÿ®Ÿäÿ™ÿ≤ÿß - Pizza category
    if (productName.includes("ÿ®Ÿäÿ™ÿ≤ÿß") || productName.includes("pizza") || productName.includes("ÿ®Ÿäÿ≤ÿß")) {
      return "üçï ÿ®Ÿäÿ™ÿ≤ÿß"
    }

    // ŸÖŸÉÿ±ŸàŸÜÿßÿ™ - Pasta category
    if (
      productName.includes("ŸÖŸÉÿ±ŸàŸÜÿ©") ||
      productName.includes("ŸÖŸÉÿ±ŸàŸÜÿßÿ™") ||
      productName.includes("ÿ®ÿßÿ≥ÿ™ÿß") ||
      productName.includes("pasta") ||
      productName.includes("ÿ≥ÿ®ÿßÿ¨Ÿäÿ™Ÿä") ||
      productName.includes("spaghetti") ||
      productName.includes("ÿ®ŸäŸÜŸä") ||
      productName.includes("penne") ||
      productName.includes("ŸÅŸàÿ™Ÿàÿ™ÿ¥ŸäŸÜŸä") ||
      productName.includes("ŸÅŸäÿ™Ÿàÿ™ÿ¥ŸäŸÜŸä")
    ) {
      return "üçù ŸÖŸÉÿ±ŸàŸÜÿßÿ™"
    }

    // ŸÉÿ±Ÿäÿ®ÿßÿ™ - Crepes category
    if (
      productName.includes("ŸÉÿ±Ÿäÿ®") ||
      productName.includes("ŸÉÿ±Ÿäÿ®ÿ©") ||
      productName.includes("ŸÉÿ±Ÿäÿ®ÿßÿ™") ||
      productName.includes("crepe") ||
      productName.includes("crepes")
    ) {
      return "ü•û ŸÉÿ±Ÿäÿ®ÿßÿ™"
    }

    // ŸÉÿ¥ÿ±Ÿä - Koshari category
    if (
      productName.includes("ŸÉÿ¥ÿ±Ÿä") ||
      productName.includes("ŸÉÿ¥ÿ±Ÿâ") ||
      productName.includes("koshari") ||
      productName.includes("koshary")
    ) {
      return "üçö ŸÉÿ¥ÿ±Ÿä"
    }

    // ŸÅÿ∑ÿßŸäÿ± - Pies/Pastries category
    if (
      productName.includes("ŸÅÿ∑Ÿäÿ±ÿ©") ||
      productName.includes("ŸÅÿ∑ÿßŸäÿ±") ||
      productName.includes("ŸÅÿ∑ÿßÿ¶ÿ±") ||
      productName.includes("pie") ||
      productName.includes("ŸÖÿπÿ¨ŸÜÿßÿ™") ||
      productName.includes("ÿπÿ¨ŸäŸÜÿ©") ||
      productName.includes("ÿ¨ÿ®ŸÜÿ© Ÿàÿ≤ÿπÿ™ÿ±") ||
      productName.includes("ÿ≥ÿ®ÿßŸÜÿÆ") ||
      productName.includes("ŸÑÿ≠ŸÖÿ© ŸÖŸÅÿ±ŸàŸÖÿ©")
    ) {
      return "ü•ß ŸÅÿ∑ÿßŸäÿ±"
    }

    // ÿ≥ŸÜÿØŸàÿ¥ÿ™ÿßÿ™ - Sandwiches category
    if (
      productName.includes("ÿ≥ÿßŸÜÿØŸàŸäÿ™ÿ¥") ||
      productName.includes("ÿ≥ŸÜÿØŸàÿ™ÿ¥") ||
      productName.includes("ÿ≥ŸÜÿØŸàÿ¥") ||
      productName.includes("ÿ≥ŸÜÿØŸàÿ¥ÿ©") ||
      productName.includes("ÿ≥ŸÜÿØŸàÿ¥ÿ™ÿßÿ™") ||
      productName.includes("sandwich") ||
      productName.includes("ÿ®ÿ±ÿ¨ÿ±") ||
      productName.includes("burger") ||
      productName.includes("ŸáŸàÿ™ ÿØŸàÿ¨") ||
      productName.includes("hot dog") ||
      productName.includes("ÿ¥ÿßŸàÿ±ŸÖÿß") ||
      productName.includes("ŸÅÿßŸáŸäÿ™ÿß") ||
      productName.includes("ŸÉÿ®ÿßÿ®") ||
      productName.includes("ŸÉŸÅÿ™ÿ©") ||
      productName.includes("ŸÅÿ±ÿßÿÆ ŸÖÿ¥ŸàŸäÿ©") ||
      productName.includes("ÿ™ŸàŸÜÿ©") ||
      productName.includes("ÿ¨ÿ®ŸÜÿ© ÿ±ŸàŸÖŸä") ||
      productName.includes("ÿ®ÿ≥ÿ∑ÿ±ŸÖÿ©")
    ) {
      return "ü•™ ÿ≥ŸÜÿØŸàÿ¥ÿ™ÿßÿ™"
    }

    // Additional beverages detection (in case you have drinks)
    if (
      productName.includes("ŸÖÿ¥ÿ±Ÿàÿ®") ||
      productName.includes("ÿπÿµŸäÿ±") ||
      productName.includes("ŸÇŸáŸàÿ©") ||
      productName.includes("ÿ¥ÿßŸä") ||
      productName.includes("ŸÉŸàŸÑÿß") ||
      productName.includes("ŸÖÿßÿ°") ||
      productName.includes("ŸÉŸàŸÉÿß") ||
      productName.includes("ÿ®Ÿäÿ®ÿ≥Ÿä") ||
      productName.includes("ŸÅÿßŸÜÿ™ÿß") ||
      productName.includes("ÿ≥ÿ®ÿ±ÿßŸäÿ™") ||
      productName.includes("ŸÜÿ≥ŸÉÿßŸÅŸäŸá") ||
      productName.includes("ŸÉÿßÿ®ÿ™ÿ¥ŸäŸÜŸà") ||
      productName.includes("ŸÑÿßÿ™ŸäŸá") ||
      productName.includes("ŸÖŸàŸÉÿß")
    ) {
      return "ü•§ ŸÖÿ¥ÿ±Ÿàÿ®ÿßÿ™"
    }

    // Additional desserts detection (in case you have desserts)
    if (
      productName.includes("ÿ≠ŸÑŸàŸäÿßÿ™") ||
      productName.includes("ŸÉŸäŸÉ") ||
      productName.includes("ÿ≠ŸÑŸàŸâ") ||
      productName.includes("ÿ¢Ÿäÿ≥ ŸÉÿ±ŸäŸÖ") ||
      productName.includes("ÿ™Ÿàÿ±ÿ™ÿ©") ||
      productName.includes("ÿ¨ÿßÿ™ŸàŸá") ||
      productName.includes("ÿ®ÿ≥ŸÉŸàŸäÿ™") ||
      productName.includes("ÿ¥ŸàŸÉŸàŸÑÿßÿ™ÿ©")
    ) {
      return "üç∞ ÿ≠ŸÑŸàŸäÿßÿ™"
    }
  }

  // Default category for unmatched items
  return "üì¶ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿ£ÿÆÿ±Ÿâ"
}

// Main Component
export default function ShiftAwareOrdersPage() {
  // State
  const [orders, setOrders] = useState<Order[]>([])
  const [stats, setStats] = useState<OrderStats | null>(null)
  const [loading, setLoading] = useState(true)
  const [shiftLoading, setShiftLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [showDialog, setShowDialog] = useState(false)
  const [deleteOrderId, setDeleteOrderId] = useState<string | null>(null)
  const [deleteReason, setDeleteReason] = useState("")
  const [currentCashier, setCurrentCashier] = useState("")
  const [currentUser, setCurrentUser] = useState<any>(null)
  const [currentShift, setCurrentShift] = useState<Shift | null>(null)
  const [isDeleting, setIsDeleting] = useState(false)

  // Component-level ref for additional protection
  const componentFetchInProgress = useRef(false)
  const lastFetchTime = useRef(0)

  // SHIFT-AWARE FETCH FUNCTION WITH MULTIPLE PROTECTIONS
  const fetchOrders = useCallback(
    async (forceRefresh = false) => {
      if (!currentShift) {
        console.log("‚ö†Ô∏è No current shift available, skipping order fetch")
        return
      }

      const now = Date.now()
      // Debounce: Don't fetch if last fetch was less than 2 seconds ago (unless forced)
      if (!forceRefresh && now - lastFetchTime.current < 2000) {
        console.log("‚è∞ Debounced: Too soon since last fetch, skipping...")
        return
      }

      // Component-level protection
      if (componentFetchInProgress.current) {
        console.log("‚ö†Ô∏è Component fetch already in progress, skipping...")
        return
      }

      // Global protection (handled in fetchFromAPI)
      if (globalFetchInProgress && !forceRefresh) {
        console.log("üåç Global fetch in progress, skipping...")
        return
      }

      try {
        componentFetchInProgress.current = true
        lastFetchTime.current = now
        setLoading(true)
        setError(null)

        console.log(`üöÄ Starting SHIFT-AWARE fetchOrders for shift: ${currentShift.shift_id}`)

        // Fetch from both API and localStorage for the specific shift
        const [apiOrders, localOrders] = await Promise.all([
          fetchFromAPI(currentShift.shift_id),
          Promise.resolve(fetchFromLocalStorage(currentShift.shift_id)),
        ])

        // Better duplicate removal using Set for order IDs
        const seenOrderIds = new Set<string>()
        const uniqueOrders: Order[] = []

        // Add API orders first (they have priority)
        apiOrders.forEach((order) => {
          if (order.order_id && !seenOrderIds.has(order.order_id)) {
            seenOrderIds.add(order.order_id)
            uniqueOrders.push(order)
          }
        })

        // Add localStorage orders that don't exist in API
        localOrders.forEach((order) => {
          if (order.order_id && !seenOrderIds.has(order.order_id)) {
            seenOrderIds.add(order.order_id)
            uniqueOrders.push(order)
          }
        })

        // Sort by creation date (newest first)
        const finalOrders = uniqueOrders.sort((a, b) => {
          const dateA = new Date(a.created_at || 0).getTime()
          const dateB = new Date(b.created_at || 0).getTime()
          return dateB - dateA
        })

        console.log(`üéØ FINAL UNIQUE orders for shift ${currentShift.shift_id}: ${finalOrders.length}`)
        console.log(`üìã Order IDs: ${finalOrders.map((o) => o.order_id.slice(-6)).join(", ")}`)

        setOrders(finalOrders)
      } catch (err) {
        console.error("Error fetching orders:", err)
        setError(err instanceof Error ? err.message : "Failed to fetch orders")
        setOrders([])
      } finally {
        setLoading(false)
        componentFetchInProgress.current = false
      }
    },
    [currentShift],
  )

  // Calculate Stats
  const calculateStats = (orders: Order[]): OrderStats => {
    const totalOrders = orders.length
    const totalRevenue = orders.reduce((sum, order) => sum + normalizePrice(order.total_price), 0)

    const ordersByType = {
      "dine-in": orders.filter((o) => o.order_type === "dine-in").length,
      takeaway: orders.filter((o) => o.order_type === "takeaway").length,
      delivery: orders.filter((o) => o.order_type === "delivery").length,
    }

    const ordersByStatus = {
      completed: orders.length, // All orders show as completed
      cancelled: 0,
    }

    return {
      totalOrders,
      totalRevenue,
      ordersByType,
      ordersByStatus,
    }
  }

  const calculateCategorySales = (): CategorySales[] => {
    const categoryMap = new Map<string, CategorySales>()

    orders.forEach((order) => {
      order.items.forEach((item) => {
        const categoryName = getCategoryName(item)
        const productName = item.product_name || item.product?.name || "ŸÖŸÜÿ™ÿ¨ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ"
        const unitPrice = normalizePrice(item.unit_price)
        const quantity = item.quantity
        const totalAmount = unitPrice * quantity

        if (!categoryMap.has(categoryName)) {
          categoryMap.set(categoryName, {
            categoryName,
            products: {},
            categoryTotal: 0,
          })
        }

        const category = categoryMap.get(categoryName)!
        if (!category.products[productName]) {
          category.products[productName] = {
            quantity: 0,
            totalAmount: 0,
            unitPrice,
          }
        }

        category.products[productName].quantity += quantity
        category.products[productName].totalAmount += totalAmount
        category.categoryTotal += totalAmount
      })
    })

    return Array.from(categoryMap.values()).sort((a, b) => b.categoryTotal - a.categoryTotal)
  }

  // Delete Order Handler
  const handleDeleteOrder = async (orderId: string, reason: string) => {
    try {
      setIsDeleting(true)
      console.log(`üóëÔ∏è Starting delete process for order ${orderId}`)

      // Try API delete first
      const apiSuccess = await deleteOrderFromAPI(orderId, reason, currentCashier)

      // Always update localStorage regardless of API result
      deleteOrderFromLocalStorage(orderId)
      console.log(`üóëÔ∏è Removed order ${orderId} from localStorage`)

      // Refresh orders to update the UI (force refresh)
      await fetchOrders(true)

      // Show appropriate success message
      if (apiSuccess) {
        alert("‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖŸÜ ÿßŸÑŸÜÿ∏ÿßŸÖ ŸàÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä!")
      } else {
        alert("‚ö†Ô∏è ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ∑ŸÑÿ® ŸÖŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä. ŸÇÿØ Ÿäÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿ≠ÿ∞ŸÅ ŸäÿØŸàŸä ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ.")
      }
    } catch (error: any) {
      console.error("‚ùå Error deleting order:", error)
      alert(`‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ≠ÿ∞ŸÅ ÿßŸÑÿ∑ŸÑÿ®: ${error.message}`)
    } finally {
      setIsDeleting(false)
    }
  }

  // UI Helper Functions
  const getOrderTypeBadge = (type: string) => {
    switch (type) {
      case "dine-in":
        return <Badge variant="outline">ÿ™ŸÜÿßŸàŸÑ ŸÅŸä ÿßŸÑŸÖÿ∑ÿπŸÖ</Badge>
      case "takeaway":
        return <Badge variant="outline">ÿ™ŸäŸÉ ÿßŸàÿßŸä</Badge>
      case "delivery":
        return <Badge variant="outline">ÿ™ŸàÿµŸäŸÑ</Badge>
      default:
        return <Badge variant="outline">{type}</Badge>
    }
  }

  // Event Handlers
  const handleDeleteClick = (orderId: string) => {
    setDeleteOrderId(orderId)
    setDeleteReason("")
    setShowDialog(true)
  }

  const handleDialogSubmit = () => {
    if (!deleteOrderId || !deleteReason.trim()) return
    handleDeleteOrder(deleteOrderId, deleteReason)
    setShowDialog(false)
    setDeleteOrderId(null)
    setDeleteReason("")
  }

  // Initialize user and shift
  useEffect(() => {
    const initializeUserAndShift = async () => {
      try {
        setShiftLoading(true)
        // Load current user
        const user = JSON.parse(localStorage.getItem("currentUser") || "{}")
        setCurrentUser(user)
        setCurrentCashier(user?.full_name || user?.name || user?.username || "")

        if (user?.user_id) {
          // Fetch current shift
          const shift = await fetchCurrentShift(user.user_id)
          setCurrentShift(shift)
          if (!shift) {
            setError("ŸÑÿß ÿ™Ÿàÿ¨ÿØ Ÿàÿ±ÿØŸäÿ© ŸÜÿ¥ÿ∑ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿ®ÿØÿ° Ÿàÿ±ÿØŸäÿ© ÿ¨ÿØŸäÿØÿ©.")
          }
        } else {
          setError("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")
        }
      } catch (error) {
        console.error("Error initializing user and shift:", error)
        setError("ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸàÿ±ÿØŸäÿ©")
      } finally {
        setShiftLoading(false)
      }
    }

    initializeUserAndShift()
  }, [])

  // Fetch orders when shift is available
  useEffect(() => {
    if (currentShift && !shiftLoading) {
      fetchOrders()
    }
  }, [currentShift, shiftLoading, fetchOrders])

  // Calculate stats when orders change
  useEffect(() => {
    if (orders.length > 0) {
      setStats(calculateStats(orders))
    }
  }, [orders])

  // Event listener for order updates
  useEffect(() => {
    let timeoutId: NodeJS.Timeout
    const handleOrderAdded = () => {
      console.log("üì¢ Order added event received - will refetch in 3 seconds...")
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => {
        console.log("üîÑ Executing delayed refetch...")
        fetchOrders(true) // Force refresh
      }, 3000) // 3 second delay to ensure order is fully saved
    }

    window.addEventListener("orderAdded", handleOrderAdded)
    return () => {
      window.removeEventListener("orderAdded", handleOrderAdded)
      clearTimeout(timeoutId)
    }
  }, [fetchOrders])

  // Loading State
  if (shiftLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4" />
          <p>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸàÿ±ÿØŸäÿ©...</p>
        </div>
      </div>
    )
  }

  // Error State
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="text-red-500 text-xl mb-4">‚ùå</div>
          <p className="text-red-600 mb-4">{error}</p>
          <Button onClick={() => window.location.reload()}>ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©</Button>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸàÿ±ÿØŸäÿ©</h1>
          <div className="flex items-center gap-4 mt-2">
            {currentShift && (
              <div className="flex items-center gap-2">
                <Badge variant="outline" className="bg-blue-50 text-blue-700 border-blue-300">
                  <Clock className="w-3 h-3 mr-1" />
                  {currentShift.shift_name || currentShift.shift_id.slice(-6)}
                </Badge>
                <Badge variant="outline" className="bg-green-50 text-green-700 border-green-300">
                  <Users className="w-3 h-3 mr-1" />
                  {currentCashier}
                </Badge>
              </div>
            )}
          </div>
        </div>
        <div className="flex gap-2">
          <Button
            onClick={() => fetchOrders(true)}
            variant="outline"
            className="bg-blue-50 hover:bg-blue-100"
            disabled={loading}
          >
            <RefreshCw className={`w-4 h-4 mr-2 ${loading ? "animate-spin" : ""}`} />
            {loading ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ÿØŸäÿ´..." : "ÿ™ÿ≠ÿØŸäÿ´"}
          </Button>
        </div>
      </div>

      {/* Stats Cards */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Card>
            <CardContent className="p-4">
              <div className="text-2xl font-bold text-blue-600">{stats.totalOrders}</div>
              <div className="text-sm text-gray-600">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="text-2xl font-bold text-green-600">{formatPrice(stats.totalRevenue)}</div>
              <div className="text-sm text-gray-600">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="text-2xl font-bold text-purple-600">{calculateCategorySales().length}</div>
              <div className="text-sm text-gray-600">ŸÅÿ¶ÿßÿ™ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™</div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Orders List */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <FileText className="w-5 h-5 text-blue-600" />
            ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸàÿ±ÿØŸäÿ© ({orders.length})
          </CardTitle>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="flex items-center justify-center py-8">
              <div className="text-center">
                <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4" />
                <p>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™...</p>
              </div>
            </div>
          ) : orders.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              <FileText className="w-12 h-12 mx-auto mb-4 opacity-50" />
              <p>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸàÿ±ÿØŸäÿ©</p>
            </div>
          ) : (
            <ScrollArea className="h-[600px] w-full">
              <div className="space-y-4 pr-4">
                {orders.map((order) => (
                  <Card key={order.order_id} className="border-l-4 border-l-blue-500">
                    <CardContent className="p-4">
                      <div className="flex justify-between items-start mb-3">
                        <div className="flex items-center gap-3">
                          <h3 className="font-semibold text-lg">#{order.order_id.slice(-6)}</h3>
                          {getOrderTypeBadge(order.order_type)}
                        </div>
                        <div className="text-right">
                          <p className="font-bold text-lg text-green-600">
                            {formatPrice(
                              order.items.reduce(
                                (sum, item) =>
                                  sum +
                                  ((normalizePrice(item.unit_price) +
                                    (item.extras?.reduce((eSum, extra) => eSum + normalizePrice(extra.price ?? 0), 0) || 0)) *
                                    item.quantity),
                                0
                              )
                            )}
                          </p>
                          <p className="text-sm text-gray-500">
                            {new Date(order.created_at).toLocaleDateString()} -{" "}
                            {new Date(order.created_at).toLocaleTimeString()}
                          </p>
                        </div>
                      </div>

                      {/* Customer Info */}
                      <div className="flex items-center gap-4 mb-3 text-sm text-gray-600">
                        <div className="flex items-center gap-1">
                          <User className="w-4 h-4" />
                          <span>{order.customer_name}</span>
                        </div>
                        {order.phone_number && (
                          <div className="flex items-center gap-1">
                            <Phone className="w-4 h-4" />
                            <span>{order.phone_number}</span>
                          </div>
                        )}
                      </div>

                      {/* Order Details Section */}
                      <div className="mb-3 border rounded-lg bg-gray-50 p-3">
                        <h4 className="font-bold text-base text-blue-900 mb-2 border-b pb-1">ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®</h4>
                        <div className="w-full overflow-x-auto">
                          <table className="min-w-full text-sm text-right">
                            <thead>
                              <tr className="bg-blue-100">
                                <th className="py-1 px-2 font-semibold">ÿßŸÑŸÖŸÜÿ™ÿ¨</th>
                                <th className="py-1 px-2 font-semibold">ÿßŸÑÿ≠ÿ¨ŸÖ</th>
                                <th className="py-1 px-2 font-semibold">ÿßŸÑŸÉŸÖŸäÿ©</th>
                                <th className="py-1 px-2 font-semibold">ÿ≥ÿπÿ± ÿßŸÑŸàÿ≠ÿØÿ©</th>
                                <th className="py-1 px-2 font-semibold">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿπŸÜÿßÿµÿ±</th>
                                <th className="py-1 px-2 font-semibold">ÿßŸÑÿ•ÿ∂ÿßŸÅÿßÿ™</th>
                                <th className="py-1 px-2 font-semibold">ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿÆÿßÿµÿ©</th>
                              </tr>
                            </thead>
                            <tbody>
                        {order.items && order.items.length > 0 ? (
                                order.items.map((item, index) => {
                                  const itemBaseTotal = normalizePrice(item.unit_price) * item.quantity;
                                  const extrasTotal = (item.extras?.reduce((sum, extra) => sum + normalizePrice(extra.price ?? 0), 0) || 0) * item.quantity;
                                  return (
                                    <tr key={`${order.order_id}-${item.order_item_id || index}`} className="border-b last:border-b-0">
                                      <td className="py-1 px-2 font-medium">{item.product_name}</td>
                                      <td className="py-1 px-2">{item.size_name && item.size_name !== "ÿπÿßÿØŸä" ? item.size_name : "-"}</td>
                                      <td className="py-1 px-2">{item.quantity}</td>
                                      <td className="py-1 px-2">{formatPrice(item.unit_price)}</td>
                                      <td className="py-1 px-2 text-blue-700 font-semibold">{formatPrice(itemBaseTotal)}</td>
                                      <td className="py-1 px-2">
                                        {item.extras && item.extras.length > 0 ? (
                                          <div>
                                            <table className="min-w-[120px] w-full text-xs border border-blue-100 rounded">
                                              <thead>
                                                <tr className="bg-blue-50">
                                                  <th className="px-1 py-0.5">ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©</th>
                                                  <th className="px-1 py-0.5">ÿ≥ÿπÿ± ÿßŸÑŸàÿ≠ÿØÿ©</th>
                                                  <th className="px-1 py-0.5">ÿßŸÑŸÉŸÖŸäÿ©</th>
                                                  <th className="px-1 py-0.5">ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä</th>
                                                </tr>
                                              </thead>
                                              <tbody>
                                                {item.extras.map((extra, i) => (
                                                  <tr key={i}>
                                                    <td className="px-1 py-0.5">{extra.name}</td>
                                                    <td className="px-1 py-0.5">{formatPrice(extra.price ?? 0)}</td>
                                                    <td className="px-1 py-0.5">{extra.quantity ?? 1}</td>
                                                    <td className="px-1 py-0.5 text-blue-700 font-semibold">{formatPrice(normalizePrice(extra.price ?? 0) * (extra.quantity ?? 1))}</td>
                                                  </tr>
                                                ))}
                                              </tbody>
                                            </table>
                                            <div className="text-xs text-blue-700 font-semibold mt-1">ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: {formatPrice(item.extras.reduce((sum, extra) => sum + (normalizePrice(extra.price ?? 0) * (extra.quantity ?? 1)), 0))}</div>
                                          </div>
                                        ) : (
                                          <span className="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</span>
                                        )}
                                      </td>
                                      <td className="py-1 px-2">
                                        <div className="text-xs text-yellow-700 bg-yellow-50 rounded px-2 py-1 border border-yellow-200 min-w-[80px]">
                                          {(item.notes && item.notes.trim() !== "") ? (
                                            <span>{item.notes}</span>
                                          ) : (item.special_instructions && item.special_instructions.trim() !== "") ? (
                                            <span>{item.special_instructions}</span>
                                          ) : (
                                            <span className="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</span>
                                          )}
                                  </div>
                                      </td>
                                    </tr>
                                  );
                                })
                              ) : (
                                <tr>
                                  <td colSpan={7} className="text-center text-gray-500 py-2">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÜÿßÿµÿ± ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ®</td>
                                </tr>
                              )}
                            </tbody>
                          </table>
                              </div>
                      </div>

                      {/* Summary Section */}
                      <div className="mt-4 border-t pt-3 grid grid-cols-1 gap-1 text-sm bg-gray-50 rounded-lg p-3">
                        <div className="flex justify-between">
                          <span className="font-semibold">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿπŸÜÿßÿµÿ± (ÿ®ÿØŸàŸÜ ÿßŸÑÿ•ÿ∂ÿßŸÅÿßÿ™):</span>
                          <span>
                            {formatPrice(order.items.reduce((sum, item) => sum + normalizePrice(item.unit_price) * item.quantity, 0))}
                              </span>
                            </div>
                        <div className="flex justify-between">
                          <span className="font-semibold">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ•ÿ∂ÿßŸÅÿßÿ™:</span>
                          <span>
                            {formatPrice(order.items.reduce((sum, item) => sum + (item.extras?.reduce((eSum, extra) => eSum + normalizePrice(extra.price ?? 0) * (extra.quantity ?? 1), 0) || 0), 0))}
                          </span>
                          </div>
                        <div className="flex justify-between text-base border-t pt-2 mt-2">
                          <span className="font-bold text-green-700">ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÉŸÑŸä:</span>
                          <span className="font-bold text-green-700">
                            {formatPrice(
                              order.items.reduce(
                                (sum, item) =>
                                  sum +
                                  ((normalizePrice(item.unit_price) +
                                    (item.extras?.reduce((eSum, extra) => eSum + normalizePrice(extra.price ?? 0), 0) || 0)) *
                                    item.quantity),
                                0
                              )
                            )}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-semibold">ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ:</span>
                          <span>{order.payment_method === "cash" ? "ŸÜŸÇÿØŸä" : "ŸÉÿßÿ±ÿ™"}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-semibold">ÿßŸÑŸÉÿßÿ¥Ÿäÿ±:</span>
                          <span>{order.cashier_name || currentCashier}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-semibold">ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ∑ŸÑÿ®:</span>
                          <span>{new Date(order.created_at).toLocaleDateString()} - {new Date(order.created_at).toLocaleTimeString()}</span>
                        </div>
                      </div>

                      {/* Footer */}
                      <div className="flex justify-between items-center pt-3 border-t text-sm text-gray-600">
                        <span>ÿßŸÑŸÉÿßÿ¥Ÿäÿ±: {order.cashier_name || currentCashier}</span>
                        <span>ÿßŸÑÿØŸÅÿπ: {order.payment_method === "cash" ? "ŸÜŸÇÿØŸä" : "ŸÉÿßÿ±ÿ™"}</span>
                        <Button
                          variant="destructive"
                          size="sm"
                          onClick={() => handleDeleteClick(order.order_id)}
                          disabled={isDeleting}
                        >
                          {isDeleting ? (
                            <Loader2 className="w-4 h-4 mr-1 animate-spin" />
                          ) : (
                            <Trash2 className="w-4 h-4 mr-1" />
                          )}
                          ÿ≠ÿ∞ŸÅ
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </ScrollArea>
          )}
        </CardContent>
      </Card>

      {/* Delete Dialog */}
      <Dialog open={showDialog} onOpenChange={setShowDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>ÿ≥ÿ®ÿ® ÿ≠ÿ∞ŸÅ ÿßŸÑÿ∑ŸÑÿ®</DialogTitle>
          </DialogHeader>
          <Textarea
            value={deleteReason}
            onChange={(e) => setDeleteReason(e.target.value)}
            placeholder="Ÿäÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿ≥ÿ®ÿ® ÿ≠ÿ∞ŸÅ ÿßŸÑÿ∑ŸÑÿ®..."
            rows={4}
          />
          <DialogFooter>
            <Button onClick={handleDialogSubmit} disabled={!deleteReason.trim() || isDeleting}>
              {isDeleting ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ∞ŸÅ...
                </>
              ) : (
                "ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ"
              )}
            </Button>
            <Button variant="outline" onClick={() => setShowDialog(false)} disabled={isDeleting}>
              ÿ•ŸÑÿ∫ÿßÿ°
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
